pub mod indicators;
pub mod dca;

use rust_decimal::Decimal;
use serde_json::Value;
use crate::exchange_connectors::Kline;
use crate::utils::errors::AppError;

/// Trade signal generated by a strategy
#[derive(Debug, Clone)]
pub enum TradeSignal {
    Buy(Decimal),    // Amount to buy
    Sell(Decimal),   // Quantity to sell
}

/// Base trait that all trading strategies must implement
pub trait Strategy {
    /// Initialize the strategy with parameters
    fn initialize(&mut self, parameters: &Value) -> Result<(), AppError>;

    /// Analyze historical data at a specific index and return a trade signal
    fn analyze(&mut self, data: &[Kline], current_index: usize) -> Option<TradeSignal>;

    /// Get the reason for the last signal generated
    fn get_last_signal_reason(&self) -> String;

    /// Get strategy name
    fn name(&self) -> &'static str;

    /// Get strategy description
    fn description(&self) -> &'static str;

    /// Get required parameters schema (JSON Schema format)
    fn parameters_schema(&self) -> Value;

    /// Validate parameters
    fn validate_parameters(&self, parameters: &Value) -> Result<(), AppError> {
        // Default validation - can be overridden
        if parameters.is_object() {
            Ok(())
        } else {
            Err(AppError::BadRequest("Parameters must be a JSON object".to_string()))
        }
    }
}

/// Registry for available strategies
pub struct StrategyRegistry;

/// Factory for creating strategy instances
pub struct StrategyFactory;

impl StrategyRegistry {
    /// Get a list of all available strategies
    pub fn list_strategies() -> Vec<&'static str> {
        vec![
            "dca",
        ]
    }

    /// Create a strategy instance by name
    pub fn create_strategy(name: &str) -> Result<Box<dyn Strategy>, AppError> {
        match name.to_lowercase().as_str() {
            "dca" => Ok(Box::new(dca::DCAStrategy::new())),
            _ => Err(AppError::BadRequest(format!("Unknown strategy: {}", name))),
        }
    }

    /// Get strategy information without creating an instance
    pub fn get_strategy_info(name: &str) -> Result<StrategyInfo, AppError> {
        let strategy = Self::create_strategy(name)?;
        Ok(StrategyInfo {
            name: strategy.name(),
            description: strategy.description(),
            parameters_schema: strategy.parameters_schema(),
        })
    }
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct StrategyInfo {
    pub name: &'static str,
    pub description: &'static str,
    pub parameters_schema: Value,
}

impl StrategyFactory {
    /// Create a strategy instance with parameters
    pub fn create(name: &str, parameters: Value) -> Result<Box<dyn Strategy>, AppError> {
        let mut strategy = match name.to_lowercase().as_str() {
            "dca" => Box::new(dca::DCAStrategy::new()) as Box<dyn Strategy>,
            "sma_crossover" => {
                // Placeholder for SMA crossover strategy
                return Err(AppError::BadRequest("SMA crossover strategy not yet implemented".to_string()));
            }
            "rsi" => {
                // Placeholder for RSI strategy
                return Err(AppError::BadRequest("RSI strategy not yet implemented".to_string()));
            }
            "macd" => {
                // Placeholder for MACD strategy
                return Err(AppError::BadRequest("MACD strategy not yet implemented".to_string()));
            }
            _ => return Err(AppError::BadRequest(format!("Unknown strategy: {}", name))),
        };

        // Initialize with parameters
        strategy.initialize(&parameters)?;
        Ok(strategy)
    }
}