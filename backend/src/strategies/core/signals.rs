use chrono::{DateTime, Utc};
use rust_decimal::{Decimal, prelude::FromPrimitive};
use serde::{Deserialize, Serialize};

/// Signal generated by a trading strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategySignal {
    /// Type of signal
    pub signal_type: StrategySignalType,
    /// Symbol to trade
    pub symbol: String,
    /// Signal strength (0.0 to 1.0)
    pub strength: Decimal,
    /// Reason for the signal
    pub reason: String,
    /// Recommended action
    pub action: SignalAction,
    /// Signal metadata
    pub metadata: SignalMetadata,
    /// Timestamp when signal was generated
    pub timestamp: DateTime<Utc>,
}

/// Type of trading signal
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum StrategySignalType {
    /// Enter a position (buy/long)
    Enter,
    /// Exit a position (sell/short)
    Exit,
    /// Add to existing position
    AddToPosition,
    /// Reduce existing position
    ReducePosition,
    /// Stop loss triggered
    StopLoss,
    /// Take profit triggered
    TakeProfit,
    /// Rebalance positions
    Rebalance,
    /// Emergency exit (market conditions)
    EmergencyExit,
}

/// Recommended action details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignalAction {
    /// Order type to use
    pub order_type: OrderType,
    /// Quantity to trade (can be absolute or percentage)
    pub quantity: QuantityType,
    /// Price constraints
    pub price: PriceConstraint,
    /// Time constraints
    pub time_constraint: Option<TimeConstraint>,
    /// Risk management
    pub risk_management: Option<RiskManagement>,
}

/// Order types supported
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderType {
    Market,
    Limit(Decimal),
    StopMarket(Decimal),
    StopLimit { stop_price: Decimal, limit_price: Decimal },
}

/// Quantity specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum QuantityType {
    /// Fixed quantity
    Fixed(Decimal),
    /// Percentage of available balance
    BalancePercentage(Decimal),
    /// Percentage of current position
    PositionPercentage(Decimal),
    /// Dollar amount to invest
    DollarAmount(Decimal),
    /// All available balance
    AllAvailable,
    /// All current position
    AllPosition,
}

/// Price constraints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PriceConstraint {
    /// No price constraint (market order)
    None,
    /// Maximum price for buy, minimum price for sell
    Limit(Decimal),
    /// Price range
    Range { min: Decimal, max: Decimal },
    /// Percentage from current price
    PercentageFromCurrent(Decimal),
}

/// Time constraints for order execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeConstraint {
    /// Execute immediately
    pub immediate: bool,
    /// Execute after this time
    pub not_before: Option<DateTime<Utc>>,
    /// Cancel if not executed by this time
    pub expires_at: Option<DateTime<Utc>>,
    /// Good till cancelled
    pub gtc: bool,
}

/// Risk management parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskManagement {
    /// Stop loss price/percentage
    pub stop_loss: Option<StopLossType>,
    /// Take profit price/percentage
    pub take_profit: Option<TakeProfitType>,
    /// Maximum position size
    pub max_position_size: Option<Decimal>,
    /// Maximum risk per trade (as percentage of balance)
    pub max_risk_per_trade: Option<Decimal>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StopLossType {
    Fixed(Decimal),
    Percentage(Decimal),
    Trailing { distance: Decimal, activation: Option<Decimal> },
    ATR { multiplier: Decimal, period: usize },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TakeProfitType {
    Fixed(Decimal),
    Percentage(Decimal),
    RiskRewardRatio(Decimal),
    Stepped(Vec<TakeProfitLevel>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TakeProfitLevel {
    pub price: Decimal,
    pub quantity_percentage: Decimal,
}

/// Signal metadata for additional context
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SignalMetadata {
    /// Confidence level (0.0 to 1.0)
    pub confidence: Option<Decimal>,
    /// Expected return
    pub expected_return: Option<Decimal>,
    /// Time horizon for the signal
    pub time_horizon: Option<String>,
    /// Technical indicators that contributed to signal
    pub indicators: Vec<IndicatorValue>,
    /// Market conditions
    pub market_conditions: Option<String>,
    /// Custom strategy-specific data
    pub custom_data: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndicatorValue {
    pub name: String,
    pub value: Decimal,
    pub signal: String, // "bullish", "bearish", "neutral"
}

impl StrategySignal {
    /// Create a simple buy signal
    pub fn buy(
        symbol: String,
        quantity: QuantityType,
        reason: String,
        strength: Option<Decimal>,
    ) -> Self {
        Self {
            signal_type: StrategySignalType::Enter,
            symbol,
            strength: strength.unwrap_or(Decimal::new(1, 0)),
            reason,
            action: SignalAction {
                order_type: OrderType::Market,
                quantity,
                price: PriceConstraint::None,
                time_constraint: None,
                risk_management: None,
            },
            metadata: SignalMetadata::default(),
            timestamp: chrono::Utc::now(),
        }
    }

    /// Create a simple sell signal
    pub fn sell(
        symbol: String,
        quantity: QuantityType,
        reason: String,
        strength: Option<Decimal>,
    ) -> Self {
        Self {
            signal_type: StrategySignalType::Exit,
            symbol,
            strength: strength.unwrap_or(Decimal::new(1, 0)),
            reason,
            action: SignalAction {
                order_type: OrderType::Market,
                quantity,
                price: PriceConstraint::None,
                time_constraint: None,
                risk_management: None,
            },
            metadata: SignalMetadata::default(),
            timestamp: chrono::Utc::now(),
        }
    }

    /// Create a DCA buy signal
    pub fn dca_buy(
        symbol: String,
        amount: Decimal,
        reason: String,
    ) -> Self {
        Self {
            signal_type: StrategySignalType::Enter,
            symbol,
            strength: Decimal::new(8, 1), // 0.8
            reason,
            action: SignalAction {
                order_type: OrderType::Market,
                quantity: QuantityType::DollarAmount(amount),
                price: PriceConstraint::None,
                time_constraint: Some(TimeConstraint {
                    immediate: true,
                    not_before: None,
                    expires_at: None,
                    gtc: false,
                }),
                risk_management: None,
            },
            metadata: SignalMetadata::default(),
            timestamp: chrono::Utc::now(),
        }
    }

    /// Add stop loss to signal
    pub fn with_stop_loss(mut self, stop_loss: StopLossType) -> Self {
        if self.action.risk_management.is_none() {
            self.action.risk_management = Some(RiskManagement {
                stop_loss: None,
                take_profit: None,
                max_position_size: None,
                max_risk_per_trade: None,
            });
        }

        if let Some(ref mut risk_mgmt) = self.action.risk_management {
            risk_mgmt.stop_loss = Some(stop_loss);
        }

        self
    }

    /// Add take profit to signal
    pub fn with_take_profit(mut self, take_profit: TakeProfitType) -> Self {
        if self.action.risk_management.is_none() {
            self.action.risk_management = Some(RiskManagement {
                stop_loss: None,
                take_profit: None,
                max_position_size: None,
                max_risk_per_trade: None,
            });
        }

        if let Some(ref mut risk_mgmt) = self.action.risk_management {
            risk_mgmt.take_profit = Some(take_profit);
        }

        self
    }

    /// Add confidence level
    pub fn with_confidence(mut self, confidence: Decimal) -> Self {
        self.metadata.confidence = Some(confidence);
        self
    }

    /// Add indicator values that contributed to the signal
    pub fn with_indicators(mut self, indicators: Vec<IndicatorValue>) -> Self {
        self.metadata.indicators = indicators;
        self
    }
}